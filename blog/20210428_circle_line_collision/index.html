<html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><link rel=stylesheet href=https://www.w3schools.com/w3css/4/w3.css><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Ubuntu"><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Inconsolata"><link rel=stylesheet href=/css/common.css><link rel="shortcut icon" type=image/png href=/img/favicon.png><title>Gerald's Website</title><script>MathJax={tex:{inlineMath:[['$','$'],['\\(','\\)']],displayMath:[['$$','$$'],['\\[','\\]']],processEscapes:!0,processEnvironments:!0},options:{skipHtmlTags:['script','noscript','style','textarea','pre']}},window.addEventListener('load',a=>{document.querySelectorAll("mjx-container").forEach(function(a){a.parentElement.classList+='has-jax'})})</script><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script><script type=text/javascript id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script></head><body><div class=profile><a href=/><img class=profile-img-back src=/img/profile.jpg loading=lazy></a><div class=profile-text>Gerald's Stuff</div><div class=profile-subtext>Blog</div></div><div class=blog-container><div class=blog-body><h1 class=blog-content-title>Circle-Finite Line Collision</h1><h4 class=blog-content-date><time datetime=2021-04-28T12:00:00+08:00>Apr 28, 2021</time></h4><p class=blog-content-body><p>Recently, I had to derive this particular collision detection algorithm for my bullet hell genre game. It&rsquo;s an interesting algorithm that can be expanded to deal with the &lsquo;moving circle vs static circle&rsquo; and &lsquo;moving circle vs moving circle&rsquo; problems.</p><p>(PS, maybe one day I&rsquo;ll use latex to make the notations easier to read)</p><p>Note that this article does not take into account collision responses; its goal is simply to check if the objects involved are colliding (but perhaps it is possible to derive the variables needed for collision response from this algorithm).</p><p>Also, a disclaimer here is that, we assume that whoever is reading the article is familiar with Linear Algebra or at least vector-related math. I won&rsquo;t go into details of vector-specific operators such as projection and dot product. That is hopefully for another article for another time.</p><h2 id=circle-finite-line-collision-check>Circle-Finite Line Collision Check</h2><p>We are given a line <code>$ l $</code> where <code>$ \dot{m} $</code> and <code>$ \dot{n} $</code> represents the start and end point of the line segment respectively. We are also given a circle which an origin at point <code>$ \dot{c} $</code> with radius <code>$ r $</code>. Determine whether the circle is colliding with the line.</p><p><img src=/img/blog_img/20210428_circle_line_collision/1.jpg alt></p><p>The general idea is to find the point on the line <code>$ l $</code> which will be the shortest distance from the line <code>$ c $</code>. We will call this point <code>$ \dot{s} $</code>, and the shortest distance <code>$ d $</code>. Next, we need to figure out whether this point <code>$\dot{s}$</code> exists within our line segment. Finally, we figure out if <code>$ d $</code> is greater than <code>$ r $</code>. If it is not, it means that it is intersecting. For all other cases, it does not intersect. In other words:</p><ul><li>Find <code>$ \dot{s} $</code> and <code>$d$</code>.</li><li>Check if <code>$ \dot{s} $</code> exists within our line. If it is not, we are not intersecting</li><li>Check if <code>$d$</code> is greater than <code>$r$</code>. If it is not, we are intersecting.</li></ul><p><img src=/img/blog_img/20210428_circle_line_collision/2.jpg alt></p><p>There is a small caveat we need to cover before we continue, regarding checking if <code>$ \dot{s} $</code> exists within our line. It would not cover the case illustrated below.</p><p><img src=/img/blog_img/20210428_circle_line_collision/3.jpg alt></p><p>Thankfully, this is conceptually easy to solve. We extend our line ends (<code>$ \dot{m} $</code> and <code>$ \dot{n} $</code>) by a factor of <code>$r$</code>. We update our list:</p><ul><li>Extend <code>$ \dot{m} $</code> and <code>$ \dot{n} $</code> line segment end points by <code>$r$</code></li><li>Find <code>$ \dot{s} $</code> and <code>$d$</code>.</li><li>Check if <code>$ \dot{s} $</code> exists within our line. If it is not, we are not intersecting</li><li>Check if <code>$d$</code> is greater than <code>$r$</code>. If it is not, we are intersecting.</li></ul><h2 id=extend-line-segment-start-and-end-points-by-a-factor-of-the-circles-radius>Extend line segment start and end points by a factor of the circle&rsquo;s radius</h2><p>First, we need to find the unit vector to extend <code>$ \dot{m} $</code> and <code>$ \dot{n} $</code>. First, get the vector <code>$ \vec{v} $</code> that goes from <code>$ \dot{m} $</code> to <code>$ \dot{n} $</code> by subtracting <code>$ \dot{m} $</code> from <code>$ \dot{n} $</code> :</p><p>$ \vec{v} = \dot{n} - \dot{m} $</p><p>then we normalize it to get the unit vector <code>$ \hat{v} $</code>, where <code>$|\vec{v}|$</code> is the magnitude/length of <code>$ \vec{v} $</code>:</p><p>$ \hat{v} = \dfrac{\vec{v}}{|\vec{v}|} $</p><p>Since <code>$\hat{v}$</code> is the unit vector of <code>$ \vec{v} $</code>, we simply multiply it with <code>$r$</code> to get the amount to translate <code>$ \dot{m} $</code> and <code>$ \dot{n} $</code> to &lsquo;extend&rsquo; the line. Thus, our new <code>$ \dot{m} $</code> and <code>$ \dot{n} $</code> (which we will denote as <code>$ \dot{m'} $</code> and <code>$ \dot{n'} $</code>) will be:</p><p>$ \dot{m'} = \dot{m} - (\hat{v} * r) $</p><p>$ \dot{n'} = \dot{n} + (\hat{v} * r) $</p><h2 id=find-the-point-that-is-the-shortest-distance-from-the-line-to-the-circle>Find the point that is the shortest distance from the line to the circle</h2><p>For those familiar with vector arithmetic, to find the point <code>$ \dot{s} $</code>, it is simply the projection of the vector formed by <code>$ (\dot{c} - \dot{m}) $</code> onto <code>$ \vec{v} $</code>. I would suggest those not familiar with projection to give it a look. Anyway, the formula is simply:</p><p>$ \dot{s} = \dfrac{((\dot{c} - \dot{m}) ・\vec{v} }{\vec{|v|}} * \hat{v} + \dot{m} $</p><h2 id=check-if-s-is-within-our-line>Check if s is within our line</h2><p>This is easier than it looks. Imaging that we have a line formed by <code>$ \dot{m} + t(v) $</code>, where <code>$t$</code> represents a scalar value such that if it is 0, we will get <code>$ \dot{m} $</code> and if it is 1, we will get <code>$ \dot{n} $</code>.</p><p>In other words, <code>$t$</code> is a ratio. Also, since we already know that <code>$ \dot{s} $</code> is definitely on the line, it means that we can safely say that there exists a <code>$t$</code> such that:</p><p>$ \dot{m} + t(\vec{v}) = \dot{s} $</p><p>We can then choose any element of <code>$\vec{v}$</code> to find <code>$t$</code>. Note that the element that you choose from <code>$ \vec{v} $</code> must not be 0.</p><p>I.e. if <code>$ v_x = 0 $</code>, use <code>$ v_y $</code> instead, etc. There won&rsquo;t be a case where all elements of <code>$\vec{v}$</code> is 0 because&mldr;that wouldn&rsquo;t form us the line <code>$l$</code> anymore.</p><p>$ m_x + t(v_x) = s_x $</p><p>$ t(v_x) = s_x - m_x $</p><p>$ t = \dfrac{(s_x - m_x)}{v_x} $</p><p>If <code>$t$</code> is lesser than 0 or greater than 1, we are not colliding. Otherwise, we go to the final section.</p><h2 id=check-the-distance-between-the-circle-and-the-line>Check the distance between the circle and the line</h2><p>Finally, we want to find the shortest distance <code>$d$</code> between the circle and the line. With that, we will compare it against the radius of the circle <code>$r$</code>. This is simply finding the distance between <code>$\dot{c}$</code> and <code>$\dot{s}$</code> using our favorite Pythagoras Theorem, and comparing it against <code>$r$</code>.</p><p>In fact, if you do not like dealing with square roots, we can just compare the <code>$d^2$</code> with <code>$r^2$</code></p><p>$ d^2 = (\dot{c} - \dot{s})_x * (\dot{c} - \dot{s})_x + (\dot{c} - \dot{s})_y * (\dot{c} - \dot{s})_y $</p><p>$ r^2 = r * r $</p><p>If <code>$d^2$</code> &lt; <code>$r^2$</code>, then we have a collision!</p><h2 id=conclusion>Conclusion</h2><p>Now that we have this, hopefully we can expend it to deal with other problems such as moving circles against moving circles, which will be covered in another article soon.</p></p></div></div><footer><p classname=footer-copyright-text>Powered By Hugo | v1.2 | © 2021 Gerald Wong</p></footer></body></html>