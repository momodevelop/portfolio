<html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><link rel=stylesheet href=https://www.w3schools.com/w3css/4/w3.css><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Ubuntu"><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Inconsolata"><link rel=stylesheet href=/css/common.css><link rel="shortcut icon" type=image/png href=/img/favicon.png><title>Gerald's Website</title></head><body><div class=profile><a href=/><img class=profile-img-back src=/img/profile.jpg loading=lazy></a><div class=profile-text>Gerald's Stuff</div><div class=profile-subtext>Blog</div></div><div class=blog-container><div class=blog-body><h1 class=blog-content-title>Circle-Finite Line Collision</h1><h4 class=blog-content-date><time datetime=2021-04-28T12:00:00+08:00>Apr 28, 2021</time></h4><p class=blog-content-body><p>Recently, I had to derive this particular collision detection algorithm for my bullet hell genre game. It&rsquo;s an interesting algorithm that can be expanded to deal with the &lsquo;moving circle vs static circle&rsquo; and &lsquo;moving circle vs moving circle&rsquo; problems.</p><p>(PS, maybe one day I&rsquo;ll use latex to make the notations easier to read)</p><p>Note that this article does not take into account collision responses; its goal is simply to check if the objects involved are colliding (but perhaps it is possible to derive the variables needed for collision response from this algorithm).</p><p>Also, a disclaimer here is that, we assume that whoever is reading the article is familiar with Linear Algebra or at least vector-related math. I won&rsquo;t go into details of vector-specific operators such as projection and dot product. That is hopefully for another article for another time.</p><h2 id=circle-finite-line-collision-check>Circle-Finite Line Collision Check</h2><p>We are given a line <code>l</code> denoted by points where <code>m</code> and <code>n</code> represents the start and end point of the line segment respectively. We are also given a circle which an origin at point <code>c</code> with radius <code>r</code>. Determine whether the circle is colliding with the line.</p><p><img src=/img/blog_img/20210428_circle_line_collision/1.jpg alt></p><p>The general idea is to find the point on the line <code>l</code> which will be the shortest distance from the line <code>c</code>. We will call this point <code>s</code>, and the shortest distance <code>d</code>. Next, we need to figure out whether this point <code>s</code> exists within our line segment. Finally, we figure out if <code>d</code> is greater than <code>r</code>. If it is not, it means that it is intersecting. For all other cases, it does not intersect. In other words:</p><ul><li>Find <code>s</code> and <code>d</code>.</li><li>Check if <code>s</code> exists within our line. If it is not, we are not intersecting</li><li>Check if <code>d</code> is greater than <code>r</code>. If it is not, we are intersecting.</li></ul><p><img src=/img/blog_img/20210428_circle_line_collision/2.jpg alt></p><p>There is a small caveat we need to cover before we continue, regarding checking if <code>s</code> exists within our line. It would not cover the case illustrated below.</p><p><img src=/img/blog_img/20210428_circle_line_collision/3.jpg alt></p><p>Thankfully, this is conceptually easy to solve. We extend our line ends (<code>m</code> and <code>n</code>) by a factor of <code>r</code>. We update our list:</p><ul><li>Extend <code>m</code> and <code>n</code> by <code>r</code></li><li>Find <code>s</code> and <code>d</code>.</li><li>Check if <code>s</code> exists within our line. If it is not, we are not intersecting</li><li>Check if <code>d</code> is greater than <code>r</code>. If it is not, we are intersecting.</li></ul><h2 id=extend-line-segment-start-and-end-points-by-a-factor-of-the-circles-radius>Extend line segment start and end points by a factor of the circle&rsquo;s radius</h2><p>First, we need to find the unit vector to extend <code>m</code> and <code>n</code>. First, get the vector <code>v</code> that goes from <code>m</code> to <code>n</code> by subtracting <code>m</code> from <code>n</code> :</p><pre><code>v = n - m  
</code></pre><p>then we normalize it to get the unit vector<code>w</code>, where <code>|v|</code> is the magnitude/length of <code>v</code>:</p><pre><code>w = v / |v|  
</code></pre><p>Since <code>w</code> is the unit vector of <code>v</code>, we simply multiply it with <code>r</code> to get the amount to translate <code>m</code> and <code>n</code> to &lsquo;extend&rsquo; the line. Thus, our new <code>m</code> and <code>n</code> will be:</p><pre><code>m = m - (w * r)
n = n + (w * r)
</code></pre><h2 id=find-the-point-that-is-the-shortest-distance-from-the-line-to-the-circle>Find the point that is the shortest distance from the line to the circle</h2><p>For those familiar with vector arithmetic, to find the point <code>s</code>, it is simply the projection of the vector formed by <code>(c - m)</code>, which we will call <code>f</code>, onto <code>v</code> , which is <code>(n - m)</code>. I would suggest those not familiar with projection to give it a look, but the formula is simply:</p><pre><code>s = (f ・ v)/(v * length(v))  
</code></pre><h2 id=check-if-s-is-within-our-line>Check if s is within our line</h2><p>This is easier than it looks. Imaging that we have a line formed by <code>m + t(v)</code>, where <code>t</code> represents a scalar value such that if it is 0, we will get <code>m</code> and if it is 1, we will get <code>n</code>. In other words, <code>t</code> is a ratio. Also, since we already know that <code>s</code> is definitely on the line, it means that we can safely say that there exists a <code>t</code> such that:</p><pre><code>m + t(v) = s
</code></pre><p>We can then choose any element of <code>v</code> to find <code>t</code>. Note that the element that you choose of <code>s</code> must not be 0. I.e. if <code>v.x == 0</code>, use <code>v.y</code> etc. There won&rsquo;t be a case where all elements of <code>v</code> is 0 because&mldr;that wouldn&rsquo;t form us the line <code>l</code> anymore :</p><pre><code>m.x + t(v.x) = s.x
t(v.x) = s.x - m.x
t = (s.x - m.x)/v.x
</code></pre><p>If <code>t</code> is lesser than 0 or greater than 1, we are not colliding. Otherwise, we go to the final section.</p><h2 id=check-the-distance-between-the-circle-and-the-line>Check the distance between the circle and the line</h2><p>Finally, we want to find the shortest distance <code>d</code> between the circle and the line. With that, we will compare it against the radius of the circle <code>r</code>. This is simply finding the distance between <code>c</code> and <code>s</code> using our favorite Pythagoras Theorem, and comparing it against <code>r</code>.</p><p>In fact, if you do not like dealing with square roots, we can just compare the <code>d^2</code> with <code>r^2</code></p><pre><code>cs_vec = (c - s)
d_squared = cs_vec.x * cs_vec.x + cs_vec.y + cs_vec.y
r_squared = r * r

// if d_squared &lt; r_squared, then we have a collision!
</code></pre><h2 id=conclusion>Conclusion</h2><p>Now that we have this, hopefully we can expend it to deal with other problems such as moving circles against moving circles, which will be covered in another article soon.</p></p></div></div><footer><p classname=footer-copyright-text>Powered By Hugo | v1.2 | © 2021 Gerald Wong</p></footer></body></html>