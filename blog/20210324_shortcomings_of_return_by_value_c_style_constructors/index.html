<html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><link rel=stylesheet href=https://www.w3schools.com/w3css/4/w3.css><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Ubuntu"><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Inconsolata"><link rel=stylesheet href=/css/common.css><link rel="shortcut icon" type=image/png href=/img/favicon.png><title>Gerald's Website</title></head><body><div class=profile><a href=/><img class=profile-img-back src=/img/profile.jpg loading=lazy></a><div class=profile-text>Gerald's Stuff</div><div class=profile-subtext>Blog</div></div><div class=blog-container><div class=blog-body><h1 class=blog-content-title>Shortcomings of return by value 'C-style constructors'</h1><h4 class=blog-content-date><time datetime=2021-03-24T12:00:00+08:00>Mar 24, 2021</time></h4><p class=blog-content-body><p>Recently, while coding on my personal C/C++ game engine project, I ran into a surprising shortcoming of functions that returns an object by value.</p><p>There are generally two simple ways to modify an object in C/C++ through plain functions.</p><p>Returning by value:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>v2f</span> {
    <span style=color:#66d9ef>float</span> x, y; 
};

v2f <span style=color:#a6e22e>CreateV2f</span>(<span style=color:#66d9ef>float</span> x, <span style=color:#66d9ef>float</span> y) {
    <span style=color:#66d9ef>return</span> v2f { x, y };
}

<span style=color:#75715e>// Usage
</span><span style=color:#75715e></span>v2f Vec <span style=color:#f92672>=</span> CreateV2f(<span style=color:#ae81ff>1.f</span>, <span style=color:#ae81ff>2.f</span>);
</code></pre></div><p>Modifying by pointer:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>v2f</span> {
    <span style=color:#66d9ef>float</span> x, y; 
};

<span style=color:#66d9ef>void</span> <span style=color:#a6e22e>InitV2f</span>(v2f<span style=color:#f92672>*</span> Vec, <span style=color:#66d9ef>float</span> x, <span style=color:#66d9ef>float</span> y) {
    Vec<span style=color:#f92672>-&gt;</span>x <span style=color:#f92672>=</span> x;
    Vec<span style=color:#f92672>-&gt;</span>y <span style=color:#f92672>=</span> y;
}

<span style=color:#75715e>// Usage
</span><span style=color:#75715e></span>v2f Vec <span style=color:#f92672>=</span> {};
InitV2f(<span style=color:#f92672>&amp;</span>Vec, <span style=color:#ae81ff>1.f</span>, <span style=color:#ae81ff>2.f</span>);
</code></pre></div><p>We can spend hours arguing about which one is better, but optimization and code readability aside, we can all agree that both functions generally does the same thing, at a relatively good speed.</p><p>So I have been using both styles interchangably for awhile now. Some scenarios, I feel like the first method is better while other times, the second feels better. Generally, it felt like both methods are interchangable.</p><p>However I found an interesting shortcoming of the &lsquo;Return by value method&rsquo;. Consider the scenario:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=color:#75715e>// Simple lightweight &#39;string&#39; object.
</span><span style=color:#75715e></span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>string</span> {
    <span style=color:#66d9ef>char</span><span style=color:#f92672>*</span> Data;
    <span style=color:#66d9ef>int</span> Cap;
    <span style=color:#66d9ef>int</span> Count;
};
string <span style=color:#a6e22e>CreateString</span>(<span style=color:#66d9ef>char</span><span style=color:#f92672>*</span> Buffer, <span style=color:#66d9ef>int</span> Cap) {
    string Ret <span style=color:#f92672>=</span> {};
    Ret.Data <span style=color:#f92672>=</span> Buffer;
    Ret.Cap <span style=color:#f92672>=</span> Cap;
};

<span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>foo</span> {
    u8 Buffer[<span style=color:#ae81ff>256</span>];
    string Str; 
};

foo <span style=color:#a6e22e>CreateFoo</span>() {
    foo Ret <span style=color:#f92672>=</span> {};
    Ret.Str <span style=color:#f92672>=</span> CreateString(Ret.Buffer, <span style=color:#ae81ff>256</span>);

    <span style=color:#66d9ef>return</span> Ret;
    <span style=color:#75715e>// Ret.Str.Data will be pointing to an invalid address 
</span><span style=color:#75715e></span>    <span style=color:#75715e>// after this function is called!
</span><span style=color:#75715e></span>}
</code></pre></div><p>After calling <code>CreateFoo()</code>, the object&rsquo;s <code>Str.Data</code> member will be pointing at an invalid address. Thinking about it, C++ constructors will never have this issue because you are modifying <code>this</code> (However, I have a lot of things against C++ constructors, which I might go into another article when I can).</p><p>Thankfully, the pointer version will not have the issue:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=color:#75715e>// Simple lightweight &#39;string&#39; object.
</span><span style=color:#75715e></span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>string</span> {
    <span style=color:#66d9ef>char</span><span style=color:#f92672>*</span> Data;
    <span style=color:#66d9ef>int</span> Cap;
    <span style=color:#66d9ef>int</span> Count;
};
string <span style=color:#a6e22e>CreateString</span>(<span style=color:#66d9ef>char</span><span style=color:#f92672>*</span> Buffer, <span style=color:#66d9ef>int</span> Cap) {
    string Ret <span style=color:#f92672>=</span> {};
    Ret.Data <span style=color:#f92672>=</span> Buffer;
    Ret.Cap <span style=color:#f92672>=</span> Cap;
};

<span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>foo</span> {
    u8 Buffer[<span style=color:#ae81ff>256</span>];
    string Str; 
};

<span style=color:#66d9ef>void</span> <span style=color:#a6e22e>CreateFoo</span>(foo<span style=color:#f92672>*</span> Foo) {
    Foo<span style=color:#f92672>-&gt;</span>Str <span style=color:#f92672>=</span> CreateString(Foo<span style=color:#f92672>-&gt;</span>Buffer, <span style=color:#ae81ff>256</span>);
}
</code></pre></div><p>It&rsquo;s interesting because I genuinely thought that both methods are interchangable in all situations, and that the differences between them only boils down to what I feel about low-level optimization and preferences in readability.</p></p></div></div><footer><p classname=footer-copyright-text>Powered By Hugo | v1.2 | Â© 2021 Gerald Wong</p></footer></body></html>